# Lab 3 - RSA

> Ahmed Nouralla - a.shaaban@innopolis.university

[TOC]

## Theoretical Understanding

- Asymmetric key algorithms provide two functions, everyone knows their implementation details:

  ```bash
  # Encryption
  encrypt(plaintext, publicKey) = ciphertext
  
  # Decryption
  decrypt(ciphertext, privateKey) = plaintext
  ```

- `publicKey` and `privateKey` are a pair of keys of a certain length generated by a certain algorithm (e.g, RSA-4096). A message encrypted with one of them can only be decrypted with the other.

- The convention is that, public key can be shared with everyone (send on the network), while private key (identity) should not be shared with anyone at all.

- This technique can also be used with message authentication as follows:

  ```bash
  # Signing: sender sends message along with signature
  signature = encrypt(hash(message), privateKey)
  
  # Verification: receiver verifies the signature 
  hash(message) == decrypt(signature, publicKey)
  ```

## Practical Implementation

### Task 1

1. Install OpenSSL: `sudo apt install openssl `

2. Create a 2048-bit RSA key pair using OpenSSL.

   ```bash
   # Generate private key
   $ openssl genpkey -algorithm RSA -out private_key.pem -pkeyopt rsa_keygen_bits:2048
   
   # Extract the public key from the private one
   $ openssl rsa -pubout -in private_key.pem -out public_key.pem
   writing RSA key
   
   # Show base-64 encoded public key
   $ cat public_key.pem
   -----BEGIN PUBLIC KEY-----
   MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAr0nV2IenCyWUDhbPFkNa
   efZZNNr+L41ZV0kb+Y8gl3UIqeIy6txAf9Ojzto1kDfOaPoozlt3i4CuCT21C54B
   /6Zlj5Zg177Q/3vVOUzuJXcnhr30PMfAhR1xvuTlX2zHQmNX7qhjKOjDOwknzOGc
   jcVd0g7jc6v7f+NfXPZ3Nz/hpXoLFT5Xl89TUehVrhrMNpkxGwQ/Kyte41jOfJt3
   VaTIsaLcTsXUurkPUFtCNbDCiYSDh8DMAkpWrt7hwpx5B9xFvsGfyUdqgoaO9BQA
   XjwdGbvpjllh5jsv4GGTzrJLkqd30X5bjZXcDV186jfOE8/8QNt9tY0kOy4U61A6
   CwIDAQAB
   -----END PUBLIC KEY-----
   
   # Extract the public modulus and the exponent
   $ openssl rsa -pubin -in public_key.pem -text -noout
   Public-Key: (2048 bit)
   Modulus:
       00:af:49:d5:d8:87:a7:0b:25:94:0e:16:cf:16:43:
       5a:79:f6:59:34:da:fe:2f:8d:59:57:49:1b:f9:8f:
       20:97:75:08:a9:e2:32:ea:dc:40:7f:d3:a3:ce:da:
       35:90:37:ce:68:fa:28:ce:5b:77:8b:80:ae:09:3d:
       b5:0b:9e:01:ff:a6:65:8f:96:60:d7:be:d0:ff:7b:
       d5:39:4c:ee:25:77:27:86:bd:f4:3c:c7:c0:85:1d:
       71:be:e4:e5:5f:6c:c7:42:63:57:ee:a8:63:28:e8:
       c3:3b:09:27:cc:e1:9c:8d:c5:5d:d2:0e:e3:73:ab:
       fb:7f:e3:5f:5c:f6:77:37:3f:e1:a5:7a:0b:15:3e:
       57:97:cf:53:51:e8:55:ae:1a:cc:36:99:31:1b:04:
       3f:2b:2b:5e:e3:58:ce:7c:9b:77:55:a4:c8:b1:a2:
       dc:4e:c5:d4:ba:b9:0f:50:5b:42:35:b0:c2:89:84:
       83:87:c0:cc:02:4a:56:ae:de:e1:c2:9c:79:07:dc:
       45:be:c1:9f:c9:47:6a:82:86:8e:f4:14:00:5e:3c:
       1d:19:bb:e9:8e:59:61:e6:3b:2f:e0:61:93:ce:b2:
       4b:92:a7:77:d1:7e:5b:8d:95:dc:0d:5d:7c:ea:37:
       ce:13:cf:fc:40:db:7d:b5:8d:24:3b:2e:14:eb:50:
       3a:0b
   Exponent: 65537 (0x10001)
   ```

3. Sign a text file containing my name (i.e., encrypt it's hash with the private key)

   ```bash
   # Create a text file containing my name
   $ echo "Ahmed Nouralla" > name.txt
   
   # Sign the file
   $ openssl dgst -sha256 -sign private_key.pem -out signature.bin name.txt
   
   # Show the encrypted text in base64
   $ openssl base64 -in signature.bin
   kW6vL9GfpSEiCpLQKjzaEVSS+kQdwenE8rogXXkBv/BqYKZwL9P3z023grX/fGVP
   8gH8rE9ZbSr/x3evhoLmi/hEqhLvfNLNqNAJ7I45iqIf4SX9OYhJzik/D/+I5e8e
   2CU25Y/tUzzRuOy0d4ZqgMN1c8CY08i0ThvgGlBPy1RaGJcn/cQgcQTsY45nNb5b
   olMjuz0lrSvEMnYH6j5llLpp0vnLMqRnW3hdkQ6ZdbKxTXonMmaZ+hwsyAJPwPY6
   P+TY23HzHllpoxIyfRIV+4juuVpeQ3gH5MUafx0V76F5JoZLFwCkSpuj3oWwhQ8t
   iuiUSK3ExUYh6ua4E2MzYw==
   
   # Verify the signature with public key
   $ openssl dgst -sha256 -verify public_key.pem -signature signature.bin name.txt
   Verified OK
   ```

4. Signature verification is typically everything we need to verify the message integrity (that it was not altered in transit, only the sender with knowledge of the private key could have signed it).

### Task 2

> Question: Assuming that you are generating a 1024-bit RSA key and the prime factors have a 512-bit length, what is the probability of picking the same prime factor twice?

- The [prime number theorem](https://en.wikipedia.org/wiki/Prime_number_theorem) states that the number of primes less than $n$ is approximately

$$
\pi(n) \approx \frac{n}{\ln{n}}
$$

- For a 512-bit prime, the value would be
  $$
  P = \pi(2^{512}) \approx 3.77 * 10^{151}
  $$

- When picking two numbers at random from that absurd range of possibilities, the probability of picking the same number twice would be given by
  $$
  P * \frac {1}{P^2} = \frac{1}{P} \approx 0.26 * 10^{-151}
  $$

> Why that formula you ask? Well, that is the same problem as rolling a die twice and calculating the probability of it landing on the same number twice, except now instead of a six-sided die, we have P sides.

- It's safe to say that it's highly unlikely that the algorithm picks the same prime twice. Stay secure!

### Task 3

> Question: Explain why using a good RNG is crucial for the security of RSA. Provide one reference to a real-world case where a poor RNG leads to a security vulnerability.

As discussed, RSA relies on choosing random large primes for security, a weak random number generator would make the algorithm predictable and thus, susceptible to attacks.

- While generating keys in RSA, we calculate $n = pq$ for a randomly chosen large primes.
- If the RNG is improperly seeded (as in [CVE-2008-0166](https://nvd.nist.gov/vuln/detail/CVE-2008-0166)), it would make it easier to brute-force potential generated keys.
- A vulnerability in OpenSSL would in turn affect popular technologies that rely on it like SSH and HTTPS, resulting in catastrophic damages.

### Task 4

Given the [list](https://docs.google.com/document/d/1qf28zZFMi7b_AR5GZs3FKzjvueYLZkmr9-HpJWYrg7c/edit?tab=t.0) of encrypted names, I used the [Vigenere cipher tool](https://www.dcode.fr/vigenere-cipher) and attacked using a known plain text "Ahmed", until I got a match at index **[16](https://docs.google.com/document/d/1pMiWS12Po3v3VG64TogFqxM4wcM0B6YS9ouTdA3kuII/edit?tab=t.0)**.

![](https://i.postimg.cc/wvvjynfm/image.png)

Given the modulus (public information) of two related RSA-1024 keys and assuming they share a factor, we can deduce the following:
$$
n_1 = p * q_1 \\
n_2 = p * q_2 \\
p = \text{gcd}(n_1, n_2) \implies q_1 = \frac{n_1}{p}, \space q_2 = \frac{n_1}{p}
$$
**Let's implement that with the help of online tools:**

- Converting $n_1$ and $n_2$ from hex to decimal using https://www.dcode.fr/hexadecimal-system
- Calculating $p = \text{gcd}(n_1, n_2)$ using https://www.dcode.fr/gcd
- Calculating $q_1 = \frac{n_1}{p}, \space q_2 = \frac{n_1}{p}$ using https://www.dcode.fr/big-numbers-division

**Results obtained**

```bash
n1 = 128719982421733323364822417633708972139672564763531482016213361798494625781775911705798342171099576553700871838518746912903018170793611862853437249527093576528296951074344654527117087733810452665192580660217972624510885970219771144043100946430501914165538790534236854745495041273592862277366985641626384315017

n2 = 137648401771989190079806733241602514051886369749944225373474646346280518401973389320446575185313447425588263460125367671190838927811073131361550573401062184398802723144655229281047187897027230743729164277621444794895999361734168596562645833355523209538130350119561876454981969649477678409706522224455231401593

p = 10288316840784167029099306153525200366562124851719293024896186567258855143783419295980155672280186913753503899243267967233221516187456912459877920323310079

q1 = 12511277054714266790270119033472312381202347570282074046167369391965403631429556361858517585084954396305844845000469059059120711210117491697254193082280823

q2 = 13379098243391359471221221178545760761614272526042627673758357024070362063221402491717507787476509539419309711210250654804782936600671972967834311165349767
```

Using RSA tool at https://www.dcode.fr/rsa-cipher (with e = 65537), we can also obtain the rest of the values knowing that:
$$
\phi = (p - 1) * (q - 1) \\
de \space \% \space \phi = 1
$$

```bash
phi = 128719982421733323364822417633708972139672564763531482016213361798494625781775911705798342171099576553700871838518746912903018170793611862853437249527093553728703055575910835157691900736297704900720158658850901560954926745960995931067443107757244549024228731185492611008468748931365464702962828509512978724116

d = 20666061233219067525896233857849547657867078542531367834575842544574216892379055235491556774406972313319812830689446496140585580558926774508199440614066532986456712250632983010043703244691158444319659267412746787682801153867305479144477720674149368216929897760558970551461131517399750058815247594139120834569
```

### Task 5

Knowing the parameters for the first key, we can use it to encrypt a string "Ahmed" as follows:

> [Reference](https://gist.github.com/cosu/4058678) for the script, modified to work with Python3 and latest standards.

```python
# pip install pycryptodome
from Crypto.PublicKey import RSA
from Crypto.Cipher import PKCS1_OAEP
import base64

n = 128719982421733323364822417633708972139672564763531482016213361798494625781775911705798342171099576553700871838518746912903018170793611862853437249527093576528296951074344654527117087733810452665192580660217972624510885970219771144043100946430501914165538790534236854745495041273592862277366985641626384315017
e = 65537
d = 20666061233219067525896233857849547657867078542531367834575842544574216892379055235491556774406972313319812830689446496140585580558926774508199440614066532986456712250632983010043703244691158444319659267412746787682801153867305479144477720674149368216929897760558970551461131517399750058815247594139120834569
p = 10288316840784167029099306153525200366562124851719293024896186567258855143783419295980155672280186913753503899243267967233221516187456912459877920323310079
q = 12511277054714266790270119033472312381202347570282074046167369391965403631429556361858517585084954396305844845000469059059120711210117491697254193082280823

message = "Ahmed Nouralla"
key = RSA.construct((n, e, d, p, q))
rsa = PKCS1_OAEP.new(key)

ciphertext = rsa.encrypt(message.encode())
plaintext = rsa.decrypt(ciphertext).decode()

# Uncomment to verify correctness 
# print(f"Encrypted Message: {ciphertext}\n")
# print(f"Decrypted Message: {plaintext}")

private_key = key.export_key().decode()
public_key = key.publickey().exportKey().decode()
b64_encrypted_message = base64.b64encode(ciphertext).decode()

# Print public key and the encrypted message in base64
print(public_key)
print(b64_encrypted_message)
```

**Output**

```bash
-----BEGIN PUBLIC KEY-----
MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQC3TaeoJ9R3xjatIcIPfVKfPEzZ
C8oCrFjV0/4tiVDzece3S6NGKC5811KdI+wvUtOZQuciv9Z6dtKktTju3Ski+7Vu
9cc2BUDTffOOJrPbYFqY3AfBSagTq0GIyK950iEEXryxFLrj6priehSUhkI2voNd
xulCrt9oRTKeWpGyiQIDAQAB
-----END PUBLIC KEY-----
```

```
LpRDoOTJ3XlUfk8HPfYl36rqQn34paKNtjPDSHgUHlmM08YPG4eRGAhfAOZ0lFOlFDR7HTAnQHHIaA/WFpd5OgJbslp/qzME/ZYVwAPTTk2O9rmmX1z1nUGpYygSMA6v3KJYVL8WnIIEGomYrDgZwLgM808+K2iZ5sYC0T7s1UM=
```

